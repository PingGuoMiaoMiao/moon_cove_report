// ä¿®æ”¹ä¸»å‡½æ•°
fn main {
  // è·å–å‘½ä»¤è¡Œå‚æ•°
  let args = @sys.get_cli_args()
  
  if args.length() < 4 {
    println("Usage: " + args[0] + " <coverage_path> <source_dir> <output_dir>")
    println("Example: moon run main coverage.lcov src/ reports/")
    @sys.exit(1)
  }
  
  let coverage_path = args[1]
  let source_dir = args[2]
  let output_dir = args[3]
  
  println("Processing coverage report:")
  println("Coverage file: " + coverage_path)
  println("Source directory: " + source_dir)
  println("Output directory: " + output_dir)
  
  // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
  match ensure_output_dir_exists(output_dir) {
    Ok(_) => ignore(Ok(_))
    Err(msg) => {
      println("âŒ Error creating output directory: " + msg)
      @sys.exit(1)
    }
  }
  
  // è¯»å–è¦†ç›–ç‡æ–‡ä»¶
  let mut coverage_data = CoverageData::{
    files: Map::new(),
    total_points: 0,
    covered_points: 0
  }
  match read_coverage_file(coverage_path) {
    Err(msg) => {
      println("âŒ Error reading coverage file: " + msg)
      @sys.exit(1)
    }
    Ok(data) => {
      println("âœ… Successfully read coverage data for " + 
              data.files.size().to_string() + " files")
      coverage_data = data
    }
  }
  
  // åŠ è½½æºä»£ç æ–‡ä»¶
  let source_files = load_source_files(coverage_data, source_dir)
  println("âœ… Loaded " + source_files.size().to_string() + " source files")
  
  // ç”Ÿæˆè¡Œè§†å›¾
  let views = map_to_line_view(coverage_data, source_files)
  println("âœ… Created coverage views for " + views.length().to_string() + " files")
  
  // è®¡ç®—æ€»ä½“è¦†ç›–ç‡
  let overall_coverage = get_overall_coverage(coverage_data)
  println("ğŸ“Š Overall coverage: " + overall_coverage.to_string() + "%")
  
  // ç”Ÿæˆä¸»HTMLæŠ¥å‘Š
  let main_report_html = generate_main_report(views, coverage_data)
  println("ğŸ–¥ï¸ Generated main HTML report")
  
  // ä¿å­˜ä¸»æŠ¥å‘Š
  let main_report_path = join_path(output_dir, "index.html")
  match save_report(main_report_html, main_report_path) {
    Err(msg) => {
      println("âŒ Error saving main report: " + msg)
      @sys.exit(1)
    }
    Ok(_) => {
      println("âœ… Main report successfully saved to: " + main_report_path)
    }
  }
  
  // ä¸ºæ¯ä¸ªæ–‡ä»¶ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
  let mut current_view = views
  while current_view.length() > 0 {
    match current_view.head() {
      Some(view) => {
        let detail_report_html = generate_file_detail_report(view, coverage_data)
        
        // ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å
        let safe_filename = generate_safe_filename(view.filename)
        let detail_report_path = join_path(output_dir, safe_filename)
        
        match save_report(detail_report_html, detail_report_path) {
          Err(msg) => {
            println("âŒ Error saving detail report for " + view.filename + ": " + msg)
          }
          Ok(_) => {
            println("âœ… Detail report successfully saved to: " + detail_report_path)
          }
        }
        current_view = current_view.tail()
      }
      None => break
    }
  }
  
  println("ğŸ‰ Coverage report generation complete!")
  @sys.exit(0)
}

// ç”Ÿæˆå®‰å…¨æ–‡ä»¶åçš„å‡½æ•°
fn generate_safe_filename(filename: String) -> String {
    // æ›¿æ¢æ‰€æœ‰å¯èƒ½å¼•èµ·è·¯å¾„é—®é¢˜çš„å­—ç¬¦
    filename.replace(old = "/", new = "_")
        .replace(old = "\\", new = "_")
        .replace(old = ":", new = "_")
        .replace(old = "*", new = "_")
        .replace(old = "?", new = "_")
        .replace(old = "\"", new = "_")
        .replace(old = "<", new = "_")
        .replace(old = ">", new = "_")
        .replace(old = "|", new = "_")
        .replace(old = ".", new = "_") + ".html"
}

// util.mbt
// è·¯å¾„å¤„ç†è¾…åŠ©å‡½æ•°
pub fn join_path(path1: String, path2: String) -> String {
  if path1.strip_suffix("/") != None {
    path1 + path2
  } else {
    path1 + "/" + path2
  }
}

pub fn dirname(path: String) -> String {
  // åè½¬å­—ç¬¦ä¸²
  let reversed = path.rev()
  
  // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæ–œæ  (åè½¬å)
  match reversed.find("/") {
    Some(pos) => {
      // è®¡ç®—åŸå§‹ä½ç½®
      let idx = path.length() - 1 - pos
      
      // åˆ›å»ºç©ºå­—ç¬¦ä¸²æ„å»ºå™¨
      let builder = StringBuilder::new()
      
      // å¤åˆ¶ä» 0 åˆ° idx çš„å­—ç¬¦
      for i in 0..=idx {
        match path.get_char(i) {
          Some(c) => builder.write_char(c)
          None => break
        }
      }
      
      builder.to_string()
    }
    None => "."
  }
}

// ä¸»å‡½æ•°
pub fn read_coverage_file(path: String) -> Result[CoverageData, String] {
  try {
    let content = @fs.read_file_to_string(path)
    match parse_bisect(content) {
      Ok(data) => Ok(data)
      Err(msg) => Err("Failed to parse coverage file: " + path + ", " + msg)
    }
  } catch {
    IOError(msg) => Err("Failed to read coverage file: " + path + ", " + msg)
  }
}

pub fn load_source_files(data: CoverageData, source_dir: String) -> Map[String, String] {
  let  source_map = Map::new()
  
  for filename in data.files.keys() {
    // å¤„ç† OCaml çš„ç‰¹æ®Šæƒ…å†µ
    let source_file = match filename.strip_suffix(".re.ml") {
      Some(prefix) => prefix.to_string() // è½¬æ¢ä¸º String
      None => filename
    }
    
    // ä½¿ç”¨è‡ªå®šä¹‰çš„è·¯å¾„æ‹¼æ¥å‡½æ•°
    let file_path = join_path(source_dir, source_file)
    
    try {
      let content = @fs.read_file_to_string(file_path)
      // ä½¿ç”¨ put æ–¹æ³•æ·»åŠ å…ƒç´ 
      source_map[filename] = content
    } catch {
      IOError(msg) => println("Warning: Source file not found: " + filename + ", error: " + msg)
    }
  }
  
  source_map
}

pub fn save_report(report_html: String, output_path: String) -> Result[Unit, String] {
  try {
    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    match ensure_output_dir_exists(output_path) {
      Ok(_) => ignore(Ok(_))
      Err(msg) => return Err(msg)
    }
    
    @fs.write_string_to_file(output_path, report_html)
    Ok(())
  } catch {
    IOError(msg) => Err("Failed to write report: " + msg)
  }
}

pub fn ensure_output_dir_exists(output_path: String) -> Result[Unit, String] {
  // ä½¿ç”¨è‡ªå®šä¹‰çš„ç›®å½•åå‡½æ•°
  let dir_path = dirname(output_path)
  
  if !@fs.path_exists(dir_path) {
    try {
      @fs.create_dir(dir_path)
      Ok(())
    } catch {
      IOError(msg) => Err("Failed to create directory: " + msg)
    }
  } else {
    Ok(())
  }
}

// serializer.mbt
pub fn serialize_bisect(data: CoverageData) -> String {
  let buffer = StringBuilder::new()
  
  // æ–‡ä»¶å¤´
  buffer.write_object("BISECT-COVERAGE-4")
  
  // æ–‡ä»¶æ•°é‡
  buffer.write_object(" ")
  buffer.write_object(data.files.size().to_string())
  
  // éå†æ¯ä¸ªæ–‡ä»¶
  data.files.each(fn(filename: String, coverage: FileCoverage) {
    // æ–‡ä»¶åé•¿åº¦
    buffer.write_object(" ")
    buffer.write_object(filename.length().to_string())
    
    // æ–‡ä»¶å
    buffer.write_object(" ")
    buffer.write_object(filename)
    
    // ç‚¹ä½æ•°æ®ï¼ˆæ¯ä¸¤ä¸ªå…ƒç´ è¡¨ç¤ºä¸€ä¸ªç‚¹ä½ï¼‰
    let mut points_arr = @list.empty()
    coverage.points.each(fn(point: CoveragePoint) {
      points_arr = @list.add(points_arr, point.start_offset)
      points_arr = @list.add(points_arr, point.end_offset)
    })
    
    // ç‚¹ä½æ•°ç»„é•¿åº¦
    buffer.write_object(" ")
    buffer.write_object(points_arr.length().to_string())
    
    // ç‚¹ä½æ•°ç»„å†…å®¹
    points_arr.each(fn(point: Int) {
      buffer.write_object(" ")
      buffer.write_object(point.to_string())
    })
    
    // æ‰§è¡Œæ¬¡æ•°æ•°ç»„
    let mut counts_arr = @list.empty()
    coverage.points.each(fn(point: CoveragePoint) {
      counts_arr = @list.add(counts_arr, point.count)
    })
    
    // æ‰§è¡Œæ¬¡æ•°æ•°ç»„é•¿åº¦
    buffer.write_object(" ")
    buffer.write_object(counts_arr.length().to_string())
    
    // æ‰§è¡Œæ¬¡æ•°å†…å®¹
    counts_arr.each(fn(count: Int) {
      buffer.write_object(" ")
      buffer.write_object(count.to_string())
    })
  })
  
  // è¿”å›ç”Ÿæˆçš„å­—ç¬¦ä¸²
  buffer.to_string()
}

// ä¿®æ”¹ generate_html_report å‡½æ•°ä»¥ç”Ÿæˆå®Œæ•´çš„è¦†ç›–ç‡æŠ¥å‘Š
pub fn generate_html_report(views: @list.List[FileCoverageView], coverage_data: CoverageData) -> String {
    let overall_coverage = get_overall_coverage(coverage_data)
    let coverage_str = format_percentage(overall_coverage)
    
    // æ„å»º HTML å¤´éƒ¨
    let html_header = 
        "<!DOCTYPE html>\n" +
        "<html lang=\"en\">\n" +
        "  <head>\n" +
        "    <meta charset=\"utf-8\"/>\n" +
        "    <title>Coverage report</title>\n" +
        "    <meta name=\"description\" content=\"" + coverage_str + " coverage overall\"/>\n" +
        "    <style>\n" +
        "      body { font-family: sans-serif; margin: 0; padding: 0; line-height: 1.6; background-color: #f8f8f8; }\n" +
        "      #header { text-align: center; margin-bottom: 20px; padding: 20px; background-color: white; border-bottom: 1px solid #ddd; }\n" +
        "      h1 { margin: 0; color: #333; }\n" +
        "      h2 { margin: 10px 0 0 0; font-size: 24px; color: #4CAF50; }\n" +
        "      #files { background-color: white; margin: 0 auto; max-width: 900px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n" +
        "      .file-item { display: flex; align-items: center; padding: 10px 15px; border-bottom: 1px solid #eee; }\n" +
        "      .meter { display: inline-block; width: 100px; height: 16px; background-color: #f0f0f0; border-radius: 3px; overflow: hidden; margin-right: 15px; }\n" +
        "      .covered { display: block; height: 100%; background-color: #4CAF50; border-radius: 3px; }\n" +
        "      .percentage { display: inline-block; width: 80px; text-align: right; margin-right: 15px; color: #4CAF50; font-weight: bold; }\n" +
        "      .dirname { color: #888; }\n" +
        "      .file-link { color: #0366d6; text-decoration: none; flex: 1; }\n" +
        "      .file-link:hover { text-decoration: underline; }\n" +
        "      .file-details { display: none; background-color: white; margin: 20px auto; max-width: 900px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; }\n" +
        "      .file-header { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }\n" +
        "      .line-coverage { font-family: monospace; font-size: 14px; line-height: 1.4; }\n" +
        "      .line-number { display: inline-block; width: 40px; text-align: right; margin-right: 10px; color: #999; user-select: none; }\n" +
        "      .line-count { display: inline-block; width: 40px; text-align: right; margin-right: 10px; color: #4CAF50; font-weight: bold; user-select: none; }\n" +
        "      .line-content { white-space: pre-wrap; }\n" +
        "      .covered-line { background-color: #e8f5e9; }\n" +
        "      .uncovered-line { background-color: #ffebee; }\n" +
        "      .partial-line { background-color: #fff8e1; }\n" +
        "      .back-button { margin-bottom: 15px; padding: 5px 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 3px; cursor: pointer; }\n" +
        "      .back-button:hover { background-color: #e0e0e0; }\n" +
        "    </style>\n" +
        "  </head>\n" +
        "  <body>\n" +
        "    <div id=\"header\">\n" +
        "      <h1>Coverage report</h1>\n" +
        "      <h2>" + coverage_str + "</h2>\n" +
        "    </div>\n" +
        "    <div id=\"files\">\n"
    
    // ç”Ÿæˆæ–‡ä»¶è¡Œ
    let file_rows = generate_file_rows(views, coverage_data)
    
    // æ„å»º HTML å°¾éƒ¨
    let html_footer = 
        "    </div>\n" +
        "    <div id=\"file-details-container\"></div>\n" +
        "    <script>\n" +
        "      function showFileCoverage(filename, source, lineData) {\n" +
        "        // éšè—æ–‡ä»¶åˆ—è¡¨\n" +
        "        document.getElementById('files').style.display = 'none';\n" +
        "        \n" +
        "        // åˆ›å»ºæ–‡ä»¶è¯¦æƒ…å®¹å™¨\n" +
        "        const container = document.getElementById('file-details-container');\n" +
        "        container.innerHTML = '';\n" +
        "        \n" +
        "        // åˆ›å»ºè¿”å›æŒ‰é’®\n" +
        "        const backButton = document.createElement('div');\n" +
        "        backButton.className = 'back-button';\n" +
        "        backButton.textContent = 'â† Back to file list';\n" +
        "        backButton.onclick = function() {\n" +
        "          container.innerHTML = '';\n" +
        "          document.getElementById('files').style.display = 'block';\n" +
        "        };\n" +
        "        container.appendChild(backButton);\n" +
        "        \n" +
        "        // åˆ›å»ºæ–‡ä»¶è¯¦æƒ…åŒºåŸŸ\n" +
        "        const fileDetails = document.createElement('div');\n" +
        "        fileDetails.className = 'file-details';\n" +
        "        \n" +
        "        // æ·»åŠ æ–‡ä»¶å¤´éƒ¨\n" +
        "        const fileHeader = document.createElement('div');\n" +
        "        fileHeader.className = 'file-header';\n" +
        "        fileHeader.innerHTML = '<h3>' + filename + '</h3>';\n" +
        "        fileDetails.appendChild(fileHeader);\n" +
        "        \n" +
        "        // æ·»åŠ ä»£ç è¡Œè¦†ç›–è¯¦æƒ…\n" +
        "        const lineCoverage = document.createElement('div');\n" +
        "        lineCoverage.className = 'line-coverage';\n" +
        "        \n" +
        "        // åˆ†å‰²æºä»£ç ä¸ºè¡Œ\n" +
        "        const lines = source.split('\\n');\n" +
        "        \n" +
        "        // ä¸ºæ¯è¡Œç”ŸæˆHTML\n" +
        "        for (let i = 0; i < lines.length; i++) {\n" +
        "          const lineNumber = i + 1;\n" +
        "          const lineContent = escapeHtml(lines[i]);\n" +
        "          \n" +
        "          // è·å–è¡Œçš„æ‰§è¡Œæ¬¡æ•°\n" +
        "          const lineCount = lineData[lineNumber] || 0;\n" +
        "          \n" +
        "          // ç¡®å®šè¡Œçš„æ ·å¼ç±»\n" +
        "          let lineClass = 'uncovered-line';\n" +
        "          if (lineCount > 0) {\n" +
        "            lineClass = 'covered-line';\n" +
        "          }\n" +
        "          \n" +
        "          const lineDiv = document.createElement('div');\n" +
        "          lineDiv.className = lineClass;\n" +
        "          lineDiv.innerHTML = \n" +
        "            '<span class=\"line-number\">' + lineNumber + '</span>' +\n" +
        "            '<span class=\"line-count\">' + lineCount + '</span>' +\n" +
        "            '<span class=\"line-content\">' + lineContent + '</span>';\n" +
        "          \n" +
        "          lineCoverage.appendChild(lineDiv);\n" +
        "        }\n" +
        "        \n" +
        "        fileDetails.appendChild(lineCoverage);\n" +
        "        container.appendChild(fileDetails);\n" +
        "      }\n" +
        "      \n" +
        "      function escapeHtml(text) {\n" +
        "        return text\n" +
        "          .replace(/&/g, '&amp;')\n" +
        "          .replace(/</g, '&lt;')\n" +
        "          .replace(/>/g, '&gt;')\n" +
        "          .replace(/\"/g, '&quot;')\n" +
        "          .replace(/'/g, '&#39;');\n" +
        "      }\n" +
        "    </script>\n" +
        "  </body>\n" +
        "</html>\n"
    
    // ç»„åˆæ‰€æœ‰éƒ¨åˆ†
    html_header + file_rows + html_footer
}

// ç”Ÿæˆå•ä¸ªæ–‡ä»¶çš„è¯¦ç»†è¦†ç›–ç‡æŠ¥å‘Š
pub fn generate_file_detail_report(view: FileCoverageView, coverage_data: CoverageData) -> String {
    let file_percentage = match get_file_coverage(coverage_data, view.filename) {
        Some(percentage) => percentage
        None => 0.0
    }
    
    let percent_str = format_percentage(file_percentage)
    
    // æ„å»º HTML å¤´éƒ¨
    let html_header = 
        "<!DOCTYPE html>\n" +
        "<html lang=\"en\">\n" +
        "  <head>\n" +
        "    <meta charset=\"utf-8\"/>\n" +
        "    <title>" + view.filename + " - Coverage Report</title>\n" +
        "    <style>\n" +
        "      body { font-family: sans-serif; margin: 0; padding: 0; line-height: 1.6; background-color: #f8f8f8; }\n" +
        "      #header { text-align: center; margin-bottom: 20px; padding: 20px; background-color: white; border-bottom: 1px solid #ddd; }\n" +
        "      h1 { margin: 0; color: #333; }\n" +
        "      h2 { margin: 10px 0 0 0; font-size: 24px; color: #4CAF50; }\n" +
        "      .back-link { display: inline-block; margin: 10px 20px; padding: 5px 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 3px; text-decoration: none; color: #333; }\n" +
        "      .back-link:hover { background-color: #e0e0e0; }\n" +
        "      .file-details { background-color: white; margin: 0 auto; max-width: 1200px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; }\n" +
        "      .file-header { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }\n" +
        "      .line-coverage { font-family: monospace; font-size: 14px; line-height: 1.4; }\n" +
        "      .line-number { display: inline-block; width: 40px; text-align: right; margin-right: 10px; color: #999; user-select: none; }\n" +
        "      .line-count { display: inline-block; width: 40px; text-align: right; margin-right: 10px; color: #4CAF50; font-weight: bold; user-select: none; }\n" +
        "      .line-content { white-space: pre-wrap; }\n" +
        "      .covered-line { background-color: #e8f5e9; }\n" +
        "      .uncovered-line { background-color: #ffebee; }\n" +
        "      .partial-line { background-color: #fff8e1; }\n" +
        "    </style>\n" +
        "  </head>\n" +
        "  <body>\n" +
        "    <a href=\"index.html\" class=\"back-link\">â† Back to file list</a>\n" +
        "    <div class=\"file-details\">\n" +
        "      <div class=\"file-header\">\n" +
        "        <h1>" + view.filename + "</h1>\n" +
        "        <h2>" + percent_str + " covered</h2>\n" +
        "      </div>\n" +
        "      <div class=\"line-coverage\">\n"
    
    // ç”Ÿæˆä»£ç è¡Œè¦†ç›–è¯¦æƒ…
    let line_coverage = generate_line_coverage(view)
    
    // æ„å»º HTML å°¾éƒ¨
    let html_footer = 
        "      </div>\n" +
        "    </div>\n" +
        "  </body>\n" +
        "</html>\n"
    
    // ç»„åˆæ‰€æœ‰éƒ¨åˆ†
    html_header + line_coverage + html_footer
}

// ä¿®æ”¹ç”Ÿæˆæ–‡ä»¶è¡Œçš„å‡½æ•°ï¼Œä½¿ç”¨ç‚¹ä½è¦†ç›–ç‡
fn generate_file_rows(views: @list.List[FileCoverageView], coverage_data: CoverageData) -> String {
    let mut rows = ""
    
    let mut current = views
    while current.length() > 0 {
        match current.head() {
            Some(view) => {
                // ä½¿ç”¨ç‚¹ä½è¦†ç›–ç‡è€Œä¸æ˜¯è¡Œè¦†ç›–ç‡
                let file_percentage = match get_file_coverage(coverage_data, view.filename) {
                    Some(percentage) => percentage
                    None => 0.0
                }
                
                // æ ¼å¼åŒ–ç™¾åˆ†æ¯”
                let percent_str = format_percentage(file_percentage)
                
                // è·å–æ–‡ä»¶çš„ç‚¹ä½è¦†ç›–æ•°æ®
                let file_cov = match coverage_data.files.get(view.filename) {
                    Some(cov) => cov
                    None => {
                        println("è­¦å‘Š: æœªæ‰¾åˆ°æ–‡ä»¶çš„è¦†ç›–ç‡æ•°æ®: " + view.filename)
                        current = current.tail()
                        continue
                    }
                }
                
                let covered_points = file_cov.covered_points
                let total_points = file_cov.total_points
                
                // æ‹†åˆ†æ–‡ä»¶è·¯å¾„ä¸ºç›®å½•å’Œæ–‡ä»¶å
                let (dir_part, file_part) = split_path(view.filename)
                
                // æ„å»ºæ–‡ä»¶è¡Œ
                let row = 
                    "      <div class=\"file-item\">\n" +
                    "        <span class=\"meter\">\n" +
                    "          <span class=\"covered\" style=\"width: " + file_percentage.to_string() + "%;\"></span>\n" +
                    "        </span>\n" +
                    "        <span class=\"percentage\">" + percent_str + "</span>\n" +
                    "        <a href=\"" + generate_safe_filename(view.filename) + "\" class=\"file-link\">\n" +
                    "          <span class=\"dirname\">" + dir_part + "</span>" + file_part + "\n" +
                    "        </a>\n" +
                    "      </div>\n"
                
                rows = rows + row
                current = current.tail()
            }
            None => break
        }
    }
    
    if rows.is_empty() {
        rows = "      <div class=\"file-item\">\n" +
               "        <span class=\"percentage\">0%</span>\n" +
               "        <span>æœªæ‰¾åˆ°è¦†ç›–ç‡æ•°æ®</span>\n" +
               "      </div>\n"
    }
    
    rows
}

// ç”Ÿæˆæ–‡ä»¶è¯¦ç»†è¦†ç›–ç‡ä¿¡æ¯
pub fn generate_file_details(views: @list.List[FileCoverageView]) -> String {
    let mut details = ""
    
    // éå†è§†å›¾åˆ—è¡¨
    let mut current = views
    while current.length() > 0 {
        match current.head() {
            Some(view) => {
                let file_details = 
                    "    <div id=\"file-" + view.filename.replace(old = "/", new = "-").replace(old = "\\", new = "-") + "\" style=\"display: none;\" class=\"line-coverage\">\n" +
                    "      <h3>" + view.filename + "</h3>\n" +
                    "      <div>\n" +
                    generate_line_coverage(view) +
                    "      </div>\n" +
                    "    </div>\n"
                
                details = details + file_details
                current = current.tail()
            }
            None => break
        }
    }
    
    details
}

// ç”Ÿæˆè¡Œè¦†ç›–ç‡è¯¦æƒ…
fn generate_line_coverage(view: FileCoverageView) -> String {
    let mut lines = ""
    let source_lines = view.source.split("\n").collect()
    
    // éå†æ‰€æœ‰è¡Œ
    for i in 0..<source_lines.length() {
        let line_number = i + 1
        let line_content = source_lines[i].to_string()
        
        // è·å–è¡Œçš„æ‰§è¡Œæ¬¡æ•°
        let line_count = match view.lines.get(line_number) {
            Some(line_cov) => line_cov.count
            None => 0
        }
        
        // ç¡®å®šè¡Œçš„æ ·å¼ç±»
        let line_class = if line_count > 0 { "covered-line" } else { "uncovered-line" }
        
        let line = 
            "        <div class=\"" + line_class + "\">\n" +
            "          <span class=\"line-number\">" + line_number.to_string() + "</span>\n" +
            "          <span class=\"line-count\">" + line_count.to_string() + "</span>\n" +
            "          <span class=\"line-content\">" + escape_html(line_content) + "</span>\n" +
            "        </div>\n"
        
        lines = lines + line
    }
    
    lines
}

// HTMLè½¬ä¹‰å‡½æ•°
pub fn escape_html(text: String) -> String {
    text.replace(old = "&", new = "&amp;")
        .replace(old = "<", new = "&lt;")
        .replace(old = ">", new = "&gt;")
        .replace(old = "\"", new = "&quot;")
        .replace(old = "'", new = "&#39;")
        .replace(old = "`", new = "&#96;")
        .replace(old = "${", new = "\\${")
}

// æ‹†åˆ†è·¯å¾„ä¸ºç›®å½•å’Œæ–‡ä»¶å
pub fn split_path(path: String) -> (String, String) {
    // æŸ¥æ‰¾æœ€åä¸€ä¸ªæ–œæ 
    let last_slash = path.rev().find("/")
    match last_slash {
        Some(pos) => {
            let dir_end = path.length() - pos
            let dir_part = path.substring(start = 0, end = dir_end)
            let file_part = path.substring(start = dir_end)
            (dir_part, file_part)
        }
        None => ("", path)
    }
}
// è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–ç™¾åˆ†æ¯”
fn format_percentage(percentage: Double) -> String {
    if percentage == 100.0 {
        "100%"
    } else {
        // ä¿ç•™ä¸¤ä½å°æ•°
        let integer_part = percentage.to_int()
        let decimal_part = ((percentage - integer_part.to_double()) * 100.0).to_int()
        
        // ç¡®ä¿ä¸¤ä½å°æ•°
        let decimal_str = if decimal_part < 10 {
            "0" + decimal_part.to_string()
        } else {
            decimal_part.to_string()
        }
        
        integer_part.to_string() + "." + decimal_str + "%"
    }
}
// æ·»åŠ JavaScriptå‡½æ•°åˆ°HTMLå°¾éƒ¨
let html_footer: String = 
    "    </div>\n" +
    "    <script>\n" +
    "      function showFileCoverage(filename) {\n" +
    "        // éšè—æ‰€æœ‰æ–‡ä»¶è¯¦æƒ…\n" +
    "        var allDetails = document.querySelectorAll('.line-coverage');\n" +
    "        for (var i = 0; i < allDetails.length; i++) {\n" +
    "          allDetails[i].style.display = 'none';\n" +
    "        }\n" +
    "        \n" +
    "        // æ˜¾ç¤ºé€‰ä¸­çš„æ–‡ä»¶è¯¦æƒ…\n" +
    "        var fileId = 'file-' + filename.replace(/[\\\\/]/g, '-');\n" +
    "        var fileDetail = document.getElementById(fileId);\n" +
    "        if (fileDetail) {\n" +
    "          fileDetail.style.display = 'block';\n" +
    "        }\n" +
    "        \n" +
    "        // æ»šåŠ¨åˆ°æ–‡ä»¶è¯¦æƒ…\n" +
    "        if (fileDetail) {\n" +
    "          fileDetail.scrollIntoView({ behavior: 'smooth' });\n" +
    "        }\n" +
    "      }\n" +
    "    </script>\n" +
    "  </body>\n" +
    "</html>\n"

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—è¡Œè¦†ç›–ç‡
fn calculate_line_coverage(view: FileCoverageView) -> (Int, Int) {
    let total_lines = view.lines.size()
    if total_lines == 0 {
        return (0, 0)
    }
    
    // è®¡ç®—è¦†ç›–è¡Œæ•°ï¼ˆæ‰§è¡Œæ¬¡æ•°å¤§äº0çš„è¡Œï¼‰
    let covered_lines = view.lines.values().fold(init=0, fn(count, line) {
        if line.count > 0 { count + 1 } else { count }
    })
    
    (covered_lines, total_lines)
}


// ä¿®æ”¹æ–‡ä»¶è¦†ç›–ç‡è®¡ç®—å‡½æ•°
fn calculate_view_coverage(view: FileCoverageView) -> Double {
    let total_lines = view.lines.size()
    if total_lines == 0 {
        return 0.0
    }
    
    // è®¡ç®—è¦†ç›–è¡Œæ•°ï¼ˆæ‰§è¡Œæ¬¡æ•°å¤§äº0çš„è¡Œï¼‰
    let covered_lines = view.lines.values().fold(init=0, fn(count, line) {
        if line.count > 0 { count + 1 } else { count }
    })
    
    // è®¡ç®—è¦†ç›–ç‡ç™¾åˆ†æ¯”
    covered_lines.to_double() * 100.0 / total_lines.to_double()
}

// ä¿®æ”¹ generate_html_report å‡½æ•°ä»¥ç”Ÿæˆä¸»é¡µé¢
pub fn generate_main_report(views: @list.List[FileCoverageView], coverage_data: CoverageData) -> String {
    let overall_coverage = get_overall_coverage(coverage_data)
    let coverage_str = format_percentage(overall_coverage)
    
    // æ„å»º HTML å¤´éƒ¨
    let html_header = 
        "<!DOCTYPE html>\n" +
        "<html lang=\"en\">\n" +
        "  <head>\n" +
        "    <meta charset=\"utf-8\"/>\n" +
        "    <title>Coverage report</title>\n" +
        "    <meta name=\"description\" content=\"" + coverage_str + " coverage overall\"/>\n" +
        "    <style>\n" +
        "      body { font-family: sans-serif; margin: 0; padding: 0; line-height: 1.6; background-color: #f8f8f8; }\n" +
        "      #header { text-align: center; margin-bottom: 20px; padding: 20px; background-color: white; border-bottom: 1px solid #ddd; }\n" +
        "      h1 { margin: 0; color: #333; }\\n" +
        "      h2 { margin: 10px 0 0 0; font-size: 24px; color: #4CAF50; }\n" +
        "      #files { background-color: white; margin: 0 auto; max-width: 900px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n" +
        "      .file-item { display: flex; align-items: center; padding: 10px 15æé€Ÿpx; border-bottom: 1px solid #eee; }\n" +
        "      .meter { display: inline-block; width: 100px; height: 16px; background-color: #f0f0f0; border-radius: 3px; overflow: hidden; margin-right: 15px; }\n" +
        "      .covered { display: block; height: 100%; background-color: #4CAF50; border-radius: 3px; }\n" +
        "      .percentage { display: inline-block; width: 80px; text-align: right; margin-right: 15px; color: #4CAF50; font-weight: bold; }\n" +
        "      .dirname { color: #888; }\n" +
        "      .file-link { color: #0366d6; text-decoration: none; flex: 1; }\n" +
        "      .file-link:hover { text-decoration: underline; }\n" +
        "    </style>\n" +
        "  </head>\n" +
        "  <body>\n" +
        "    <div id=\"header\">\n" +
        "      <h1>Coverage report</h1>\n" +
        "      <h2>" + coverage_str + "</h2>\n" +
        "    </div>\n" +
        "    <div id=\"files\">\n"
    
    // ç”Ÿæˆæ–‡ä»¶è¡Œ
    let file_rows = generate_file_rows(views, coverage_data)
    
    // æ„å»º HTML å°¾éƒ¨
    let html_footer = 
        "    </div>\n" +
        "  </body>\n" +
        "</html>\n"
    
    // ç»„åˆæ‰€æœ‰éƒ¨åˆ†
    html_header + file_rows + html_footer
}

// query.mbt
// æŸ¥è¯¢ç‚¹ä½æ‰§è¡Œæ¬¡æ•°
pub fn get_point_execution(data: CoverageData, file: String, start: Int, end: Int) -> Option[Int] {
  match data.files.get(file) {
    Some(coverage) => {
      // ä½¿ç”¨ find æ–¹æ³•æŸ¥æ‰¾åŒ¹é…çš„ç‚¹ä½
      match coverage.points.find(fn(point: CoveragePoint) {
        point.start_offset == start && point.end_offset == end
      }) {
        Some(point) => Some(point.count)
        None => None
      }
    }
    None => None
  }
}

// æŸ¥è¯¢æ–‡ä»¶æ‰€æœ‰ç‚¹ä½
pub fn get_file_points(data: CoverageData, file: String) -> @list.List[CoveragePoint] {
  match data.files.get(file) {
    Some(coverage) => coverage.points
    None => @list.empty()
  }
}

// æŸ¥è¯¢æ–‡ä»¶è¦†ç›–ç‡ç™¾åˆ†æ¯”
pub fn get_file_coverage(data: CoverageData, file: String) -> Option[Double] {
  match data.files.get(file) {
    Some(f) => {
      if f.total_points == 0 {
        Some(0.0)
      } else {
        Some(f.covered_points.to_double() * 100.0 / f.total_points.to_double())
      }
    }
    None => None
  }
}

// ä¿®æ”¹æ€»ä½“è¦†ç›–ç‡è®¡ç®—å‡½æ•°
pub fn get_overall_coverage(data: CoverageData) -> Double {
    if data.total_points == 0 {
        0.0
    } else {
        data.covered_points.to_double() * 100.0 / data.total_points.to_double()
    }
}

// å¯¼å‡ºCSV
pub fn export_to_csv(data: CoverageData) -> String {
  let mut csv = "File,Start Offset,End Offset,Execution Count\n"
  
  // ä½¿ç”¨ each æ–¹æ³•éå†æ–‡ä»¶
  data.files.each(fn(filename: String, coverage: FileCoverage) {
    // ä½¿ç”¨ each æ–¹æ³•éå†ç‚¹ä½
    coverage.points.each(fn(point: CoveragePoint) {
      csv = csv + 
        filename + "," + 
        point.start_offset.to_string() + "," + 
        point.end_offset.to_string() + "," + 
        point.count.to_string() + "\n"
    })
  })
  
  csv
}

// parser.mbt
pub fn parse_bisect(input: String) -> Result[CoverageData, String] {
    // è¾…åŠ©å‡½æ•°ï¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°
    fn parse_int(s: String) -> Option[Int] {
        let mut num = 0
        let mut valid = false
        
        for c in s.iter() {
            let char_val = c.to_int()
            if char_val >= '0'.to_int() && char_val <= '9'.to_int() {
                num = num * 10 + (char_val - '0'.to_int())
                valid = true
            } else {
                return None
            }
        }
        
        if valid { Some(num) } else { None }
    }
    
    println("å¼€å§‹è§£æè¦†ç›–ç‡æ–‡ä»¶...")
    
    let identifier = "BISECT-COVERAGE-4"
    
    // æ£€æŸ¥æ–‡ä»¶å¤´
    if input.starts_with(identifier) == None {
        return Err("Invalid Bisect coverage file format: missing header")
    }
    
    // ç§»é™¤æ–‡ä»¶å¤´
    let content = input.strip_prefix(identifier).unwrap_or("")
    
    // åˆ†å‰²å­—ç¬¦ä¸²ä¸ºtokenåˆ—è¡¨
    let tokens = content.split(" ").filter(fn(s) { !s.is_empty() }).map(fn(s) { s.to_string() }).collect()
    println("Tokens: " + tokens.to_string())
    
    let mut index = 0
    let  files = Map::new()
    let mut total_points = 0
    let mut covered_points = 0
    
    // è§£ææ–‡ä»¶æ•°é‡
    if index >= tokens.length() {
        return Err("Missing file count")
    }
    
    let file_count = match parse_int(tokens[index]) {
        Some(count) => {
            index += 1
            count
        }
        None => return Err("Failed to parse file count: " + tokens[index])
    }
    
    println("æ–‡ä»¶æ•°é‡: " + file_count.to_string())
    
    // å¾ªç¯è§£ææ¯ä¸ªæ–‡ä»¶
    for file_idx in 0..<file_count {
        // è§£ææ–‡ä»¶åé•¿åº¦
        if index >= tokens.length() {
            return Err("Unexpected end of file while parsing filename length")
        }
        let filename_len = match parse_int(tokens[index]) {
            Some(len) => {
                index += 1
                len
            }
            None => return Err("Failed to parse filename length: " + tokens[index])
        }
        
        // è§£ææ–‡ä»¶å
        if index >= tokens.length() {
            return Err("Unexpected end of file while parsing filename")
        }
        let filename = tokens[index]
        index += 1
        
        // è§£æç‚¹ä½æ•°ç»„é•¿åº¦
        if index >= tokens.length() {
            return Err("Unexpected end of file while parsing points length")
        }
        let points_length = match parse_int(tokens[index]) {
            Some(len) => {
                index += 1
                len
            }
            None => return Err("Failed to parse points length: " + tokens[index])
        }
        
        // è§£æç‚¹ä½æ•°ç»„
        if index + points_length > tokens.length() {
            return Err("Unexpected end of file while parsing points array")
        }
        
        let mut points = @list.empty()
        for i in 0..<points_length {
            let point_val = match parse_int(tokens[index + i]) {
                Some(val) => val
                None => return Err("Failed to parse point value: " + tokens[index + i])
            }
            points = @list.add(points, point_val)
        }
        
        index += points_length
        
        // è®¡ç®—ç‚¹ä½æ•°ï¼ˆæ¯ä¸ªç‚¹ç”±ä¸¤ä¸ªæ•´æ•°è¡¨ç¤ºï¼‰
        let point_count = points_length / 2
        
        // è§£æè®¡æ•°æ•°ç»„é•¿åº¦å£°æ˜ï¼ˆä½†æˆ‘ä»¬å¿½ç•¥å®ƒï¼‰
        if index >= tokens.length() {
            return Err("Unexpected end of file while parsing counts length")
        }
        let counts_length_declared = match parse_int(tokens[index]) {
            Some(len) => {
                index += 1
                len
            }
            None => return Err("Failed to parse counts length: " + tokens[index])
        }
        
        // è§£æè®¡æ•°æ•°ç»„ - æˆ‘ä»¬åªè¯»å– point_count ä¸ªå€¼
        let mut counts = @list.empty()
        for i in 0..<point_count {
            if index >= tokens.length() {
                // å¦‚æœè®¡æ•°ä¸è¶³ï¼Œä½¿ç”¨0å¡«å……
                counts = @list.add(counts, 0)
                continue
            }
            
            let count_val = match parse_int(tokens[index]) {
                Some(val) => val
                None => 0  // å¦‚æœè§£æå¤±è´¥ï¼Œä½¿ç”¨0
            }
            
            counts = @list.add(counts, count_val)
            index += 1
        }
        
        // è·³è¿‡å¤šä½™çš„è®¡æ•°å€¼ï¼ˆå¦‚æœæœ‰ï¼‰
        let remaining_counts = counts_length_declared - point_count
        if remaining_counts > 0 {
            if index + remaining_counts > tokens.length() {
                println("âš ï¸ Warning: Extra counts missing for file: " + filename)
            } else {
                index += remaining_counts
            }
        }
        
        // æ„å»ºè¦†ç›–ç‚¹åˆ—è¡¨å¹¶è®¡ç®—è¦†ç›–ç‡
        let mut file_points_list = @list.empty()
        let mut file_covered = 0
        
        for i in 0..<point_count {
            let start_offset = match points.nth(i * 2) {
                Some(val) => val
                None => return Err("Missing start offset at index " + (i * 2).to_string())
            }
            
            let end_offset = match points.nth(i * 2 + 1) {
                Some(val) => val
                None => return Err("Missing end offset at index " + (i * 2 + 1).to_string())
            }
            
            let count = if i < counts.length() {
                counts.nth(i).unwrap_or(0)
            } else {
                0
            }
            
            if count > 0 {
                file_covered += 1
            }
            
            file_points_list = @list.add(file_points_list, CoveragePoint::{
                start_offset: start_offset,
                end_offset: end_offset,
                count: count
            })
        }
        
        // æ·»åŠ åˆ°æ–‡ä»¶é›†
        files.set(filename, FileCoverage::{
            filename: filename,
            points: file_points_list,
            total_points: point_count,
            covered_points: file_covered
        })
        
        total_points += point_count
        covered_points += file_covered
    }
    
    // è¿”å›å®Œæ•´è¦†ç›–æ•°æ®
    Ok(CoverageData::{
        files: files,
        total_points: total_points,
        covered_points: covered_points
    })
}

// merger.mbt
pub fn merge_coverage(a: CoverageData, b: CoverageData) -> CoverageData {
  // åˆ›å»º a.files çš„å‰¯æœ¬
  let merged_files = a.files.copy()
  let mut total_points = a.total_points
  let mut covered_points = a.covered_points
  
  // ä½¿ç”¨ each æ–¹æ³•éå† b.files
  b.files.each(fn(filename: String, b_file: FileCoverage) {
    match merged_files.get(filename) {
      Some(a_file) => {
        match merge_file_coverage(a_file, b_file) {
          Ok(merged_file) => {
            merged_files.set(filename, merged_file)
            total_points = total_points - a_file.total_points + merged_file.total_points
            covered_points = covered_points - a_file.covered_points + merged_file.covered_points
          }
          Err(err) => {
            println("Warning: " + err)
            // ä¿ç•™åŸå§‹æ–‡ä»¶è¦†ç›–ç‡
          }
        }
      }
      None => {
        merged_files.set(filename, b_file)
        total_points += b_file.total_points
        covered_points += b_file.covered_points
      }
    }
  })
  
  CoverageData::{
    files: merged_files,
    total_points: total_points,
    covered_points: covered_points
  }
}

fn merge_file_coverage(a: FileCoverage, b: FileCoverage) -> Result[FileCoverage, String] {
  // æ£€æŸ¥ç‚¹ä½ç»“æ„ä¸€è‡´æ€§
  if a.points.length() != b.points.length() {
    return Err("Cannot merge coverage for different versions of the same file")
  }
  
  // ä½¿ç”¨ fold å¤„ç†ç‚¹å¯¹
  let merged_points_result = 
    a.points.zip(b.points).fold(
      init = Ok(@list.empty()), 
      fn(acc: Result[@list.List[CoveragePoint], String], pair: (CoveragePoint, CoveragePoint)) {
        match acc {
          Err(err) => Err(err) // ä¿æŒå·²æœ‰é”™è¯¯
          Ok(points) => {
            let (a_point, b_point) = pair
            // æ£€æŸ¥ç‚¹ä½ä½ç½®
            if a_point.start_offset != b_point.start_offset || a_point.end_offset != b_point.end_offset {
              Err("Point offset mismatch in file " + a.filename)
            } else {
              let merged_point = CoveragePoint::{
                start_offset: a_point.start_offset,
                end_offset: a_point.end_offset,
                count: a_point.count + b_point.count
              }
              Ok(@list.add(points, merged_point))
            }
          }
        }
      }
    )
  
  match merged_points_result {
    Err(err) => Err(err)
    Ok(merged_points) => {
      // ä½¿ç”¨ fold å®ç° count åŠŸèƒ½
      let new_covered = merged_points.fold(init=0, fn(count, point) {
        if point.count > 0 { count + 1 } else { count }
      })
      
      Ok(FileCoverage::{
        filename: a.filename,
        points: merged_points,
        total_points: a.total_points,
        covered_points: new_covered
      })
    }
  }
}

// mapper.mbt
struct LineMapEntry {
  line : Int
  start_offset : Int
  end_offset : Int
}

fn build_line_map(source : String) -> @list.List[LineMapEntry] {
  println("å¼€å§‹æ„å»ºè¡Œæ˜ å°„è¡¨...")
  let mut entries : @list.List[LineMapEntry] = @list.empty()
  let mut current_offset = 0
  let mut current_line = 1
  let mut line_start = 0
  let mut char_count = 0

  for c in source.iter() {
    char_count += 1
    let char_val = c.to_int()

    // è®¡ç®—å­—ç¬¦åœ¨UTF-16ä¸­çš„é•¿åº¦
    let char_size = if char_val <= 0xFFFF { 1 } else { 2 }
    current_offset += char_size

    // é‡åˆ°æ¢è¡Œç¬¦æ—¶åˆ›å»ºæ–°è¡Œ
    if c == '\n' {
      let entry = LineMapEntry::{
        line: current_line,
        start_offset: line_start,
        end_offset: current_offset - 1, // æ¢è¡Œç¬¦å‰çš„ä½ç½®
      }

      entries = @list.add(entries, entry)
      line_start = current_offset
      current_line += 1
    }
  }

  // æ·»åŠ æœ€åä¸€è¡Œï¼ˆå¦‚æœæ²¡æœ‰ä»¥æ¢è¡Œç¬¦ç»“å°¾ï¼‰
  if char_count > 0 && source.get_char(char_count - 1) != Some('\n') {
    let entry = LineMapEntry::{
      line: current_line,
      start_offset: line_start,
      end_offset: current_offset,
    }
    entries = @list.add(entries, entry)
  }

  println("æ„å»ºè¡Œæ˜ å°„è¡¨å®Œæˆï¼Œæ€»è¡Œæ•°: " + current_line.to_string())
  entries
}
pub fn map_to_line_view(
  data : CoverageData,
  source_files : Map[String, String],
) -> @list.List[FileCoverageView] {
  let mut views : @list.List[FileCoverageView] = @list.empty()

  // éå†æ¯ä¸ªæ–‡ä»¶çš„è¦†ç›–ç‡æ•°æ®
  data.files.each(fn(filename : String, coverage : FileCoverage) {
    println("å¤„ç†æ–‡ä»¶: " + filename)
    match source_files.get(filename) {
      Some(source) => {
        println("æ‰¾åˆ°æºä»£ç æ–‡ä»¶: " + filename)
        let line_map = build_line_map(source)
        println("æ„å»ºè¡Œæ˜ å°„è¡¨å®Œæˆï¼Œè¡Œæ•°: " + line_map.length().to_string())
        
        let lines_map : Map[Int, LineCoverage] = Map::new()
        
        // åˆå§‹åŒ–è¡Œè¦†ç›–ä¿¡æ¯
        line_map.iter().each(fn(entry : LineMapEntry) {
          lines_map.set(entry.line, LineCoverage::{ line: entry.line, count: 0 })
        })
        println("åˆå§‹åŒ–è¡Œè¦†ç›–ä¿¡æ¯å®Œæˆ")
        
        // è®¡ç®—æ¯è¡Œçš„æœ€å¤§æ‰§è¡Œæ¬¡æ•°
        coverage.points.iter().each(fn(point : CoveragePoint) {
          line_map.iter().each(fn(entry : LineMapEntry) {
            // ä¿®å¤1: æ£€æŸ¥ç‚¹ä½æ˜¯å¦åœ¨è¡ŒèŒƒå›´å†…
            if point.start_offset >= entry.start_offset && point.start_offset <= entry.end_offset {
              let current = match lines_map.get(entry.line) {
                Some(lc) => lc
                None => LineCoverage::{ line: entry.line, count: 0 }
              }
              
              // å–è¯¥è¡Œç‚¹çš„æœ€å¤§æ‰§è¡Œæ¬¡æ•°
              lines_map.set(entry.line, LineCoverage::{
                line: entry.line,
                count: if point.count > current.count { point.count } else { current.count },
              })
            }
          })
        })
        println("è®¡ç®—è¡Œè¦†ç›–ç‡å®Œæˆ")
        
        // æ·»åŠ åˆ°è§†å›¾åˆ—è¡¨
        views = @list.add(views, FileCoverageView::{
          filename: filename,
          source: source,
          lines: lines_map,
        })
        println("æ·»åŠ æ–‡ä»¶è§†å›¾: " + filename)
      }
      None => println("è­¦å‘Š: æœªæ‰¾åˆ°æºä»£ç æ–‡ä»¶: " + filename)
    }
  })
  
  println("æ˜ å°„å®Œæˆï¼Œç”Ÿæˆè§†å›¾æ•°é‡: " + views.length().to_string())
  views
}

// coverage_data.mbt
pub struct CoveragePoint {
  start_offset : Int
  end_offset : Int
  count : Int
}

pub struct FileCoverage {
  filename : String
  points : @list.List[CoveragePoint]
  total_points : Int
  covered_points : Int
}

pub struct CoverageData {
  files : Map[String, FileCoverage]
  total_points : Int
  covered_points : Int
}

// ç”¨äºå¯è§†åŒ–çš„æ‰©å±•æ•°æ®ç»“æ„
pub struct LineCoverage {
  line : Int
  count : Int
}

pub struct FileCoverageView {
  filename : String
  source : String
  lines : Map[Int, LineCoverage]
}